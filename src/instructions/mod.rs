use crate::hardware;
use hardware::Op;

mod instruct_fn;

pub struct Instruct {
    pub opcode: u8,
    pub name: String,
    pub desc: String,
    pub argc: u8,
    pub ticks: u8,
    pub exec: Op,
}

impl Instruct {
    pub fn fetch(opcode: u8) -> Instruct {
        macro_rules! instruct {
            ($name:expr, $desc:expr, $argc:expr, $ticks:expr, $exec:expr) => ({ 
                Instruct {
                    opcode,
                    name: String::from($name),
                    desc: String::from($desc),
                    argc: $argc,
                    ticks: $ticks,
                    exec: $exec,
                }
            });
        }
        
        match opcode {
            //8 bit direct load
            0x3E => instruct!("LD A n", "Load n in A", 1, 8, Op::U8(instruct_fn::ld_a_u8)),
            0x06 => instruct!("LD B n", "Load n in B", 1, 8, Op::U8(instruct_fn::ld_b_u8)),
            0x0e => instruct!("LD C n", "Load n in C", 1, 8, Op::U8(instruct_fn::ld_c_u8)),
            0x16 => instruct!("LD D n", "Load n in D", 1, 8, Op::U8(instruct_fn::ld_d_u8)),
            0x1e => instruct!("LD E n", "Load n in E", 1, 8, Op::U8(instruct_fn::ld_e_u8)),
            0x26 => instruct!("LD H n", "Load n in H", 1, 8, Op::U8(instruct_fn::ld_h_u8)),
            0x2e => instruct!("LD L n ", "Load n in L", 1, 8, Op::U8(instruct_fn::ld_l_u8)),
            //Load A
            0x7f => instruct!("LD A A", "Load A in A", 0, 4, Op::No(instruct_fn::ld_a_a)),
            0x78 => instruct!("LD A B", "Load B in A", 0, 4, Op::No(instruct_fn::ld_a_b)),
            0x79 => instruct!("LD A C", "Load C in A", 0, 4, Op::No(instruct_fn::ld_a_c)),
            0x7a => instruct!("LD A D", "Load D in A", 0, 4, Op::No(instruct_fn::ld_a_d)),
            0x7b => instruct!("LD A E", "Load E in A", 0, 4, Op::No(instruct_fn::ld_a_e)),
            0x7C => instruct!("LD A H", "Load H in A", 0, 4, Op::No(instruct_fn::ld_a_h)),
            0x7D => instruct!("LD A L", "Load L in A", 0, 4, Op::No(instruct_fn::ld_a_l)),
            0x0A => instruct!("LD A (BC)", "Load ram[BC] in A", 0, 8, Op::Ram(instruct_fn::ld_a_bcp)),
            0x1A => instruct!("LD A (DE)", "Load ram[DE] in A", 0, 8, Op::Ram(instruct_fn::ld_a_dep)),
            0x7E => instruct!("LD A (HL)", "Load ram[HL] in A", 0, 8, Op::Ram(instruct_fn::ld_a_hlp)),
            0xFA => instruct!("LD A (nn)", "Load ram[nn] in A", 2, 16, Op::RamU16(instruct_fn::ld_a_u16p)),
            //Load B
            0x40 => instruct!("LD B B", "Load B in B", 0, 4, Op::No(instruct_fn::ld_b_b)),
            0x41 => instruct!("LD B C", "Load C in B", 0, 4, Op::No(instruct_fn::ld_b_c)),
            0x42 => instruct!("LD B D", "Load D in B", 0, 4, Op::No(instruct_fn::ld_b_d)),
            0x43 => instruct!("LD B E", "Load E in B", 0, 4, Op::No(instruct_fn::ld_b_e)),
            0x44 => instruct!("LD B H", "Load H in B", 0, 4, Op::No(instruct_fn::ld_b_h)),
            0x45 => instruct!("LD B L", "Load L in B", 0, 4, Op::No(instruct_fn::ld_b_l)),
            0x46 => instruct!("LD B (HL)", "Load ram[HL] in B", 0, 8, Op::Ram(instruct_fn::ld_b_hlp)),
            0x47 => instruct!("LD B A", "Load A in B", 0, 4, Op::No(instruct_fn::ld_b_a)),
            //Load C
            0x48 => instruct!("LD C B", "Load B in C", 0, 4, Op::No(instruct_fn::ld_c_b)),
            0x49 => instruct!("LD C C", "Load C in C", 0, 4, Op::No(instruct_fn::ld_c_c)),
            0x4A => instruct!("LD C D", "Load D in C", 0, 4, Op::No(instruct_fn::ld_c_d)),
            0x4B => instruct!("LD C E", "Load E in C", 0, 4, Op::No(instruct_fn::ld_c_e)),
            0x4C => instruct!("LD C H", "Load H in C", 0, 4, Op::No(instruct_fn::ld_c_h)),
            0x4D => instruct!("LD C L", "Load L in C", 0, 4, Op::No(instruct_fn::ld_c_l)),
            0x4E => instruct!("LD C (HL)", "Load ram[HL] in C", 0, 8, Op::Ram(instruct_fn::ld_c_hlp)),
            0x4f => instruct!("LD C A", "Load A in C", 0, 4, Op::No(instruct_fn::ld_c_a)),
            //Load D
            0x50 => instruct!("LD D B", "Load B in D", 0, 4, Op::No(instruct_fn::ld_d_b)),
            0x51 => instruct!("LD D C", "Load C in D", 0, 4, Op::No(instruct_fn::ld_d_c)),
            0x52 => instruct!("LD D D", "Load D in D", 0, 4, Op::No(instruct_fn::ld_d_d)),
            0x53 => instruct!("LD D E", "Load E in D", 0, 4, Op::No(instruct_fn::ld_d_e)),
            0x54 => instruct!("LD D H", "Load H in D", 0, 4, Op::No(instruct_fn::ld_d_h)),
            0x55 => instruct!("LD D L", "Load L in D", 0, 4, Op::No(instruct_fn::ld_d_l)),
            0x56 => instruct!("LD D (HL)", "Load ram[HL] in D", 0, 8, Op::Ram(instruct_fn::ld_d_hlp)),
            0x57 => instruct!("LD D A", "Load A in D", 0, 4, Op::No(instruct_fn::ld_d_a)),
            //Load E
            0x58 => instruct!("LD E B", "Load B in E", 0, 4, Op::No(instruct_fn::ld_e_b)),
            0x59 => instruct!("LD E C", "Load C in E", 0, 4, Op::No(instruct_fn::ld_e_c)),
            0x5a => instruct!("LD E D", "Load D in E", 0, 4, Op::No(instruct_fn::ld_e_d)),
            0x5b => instruct!("LD E E", "Load E in E", 0, 4, Op::No(instruct_fn::ld_e_e)),
            0x5c => instruct!("LD E H", "Load H in E", 0, 4, Op::No(instruct_fn::ld_e_h)),
            0x5d => instruct!("LD E L", "Load L in E", 0, 4, Op::No(instruct_fn::ld_e_l)),
            0x5e => instruct!("LD E (HL)", "Load ram[HL] in E", 0, 8, Op::Ram(instruct_fn::ld_e_hlp)),
            0x5F => instruct!("LD E A", "Load A in E", 0, 4, Op::No(instruct_fn::ld_e_a)),
            //Load H
            0x60 => instruct!("LD H B", "Load B in H", 0, 4, Op::No(instruct_fn::ld_h_b)),
            0x61 => instruct!("LD H C", "Load C in H", 0, 4, Op::No(instruct_fn::ld_h_c)),
            0x62 => instruct!("LD H D", "Load D in H", 0, 4, Op::No(instruct_fn::ld_h_d)),
            0x63 => instruct!("LD H E", "Load E in H", 0, 4, Op::No(instruct_fn::ld_h_e)),
            0x64 => instruct!("LD H H", "Load H in H",0, 4, Op::No(instruct_fn::ld_h_h)),
            0x65 => instruct!("LD H L", "Load L in H",0, 4, Op::No(instruct_fn::ld_h_l)),
            0x66 => instruct!("LD H (HL)", "Load ram[HL] in H", 0, 8, Op::Ram(instruct_fn::ld_h_hlp)),
            0x67 => instruct!("LD H A ", "Load A in H", 0, 4, Op::No(instruct_fn::ld_h_a)),
            //Load L
            0x68 => instruct!("LD L B", "Load B in L",0, 4, Op::No(instruct_fn::ld_l_b)),
            0x69 => instruct!("LD L C", "Load C in L",0, 4, Op::No(instruct_fn::ld_l_c)),
            0x6a => instruct!("LD L ", "Load D in L",0, 4, Op::No(instruct_fn::ld_l_d)),
            0x6b => instruct!("LD L E", "Load E in L",0, 4, Op::No(instruct_fn::ld_l_e)),
            0x6c => instruct!("LD L H", "Load H in L",0, 4, Op::No(instruct_fn::ld_l_h)),
            0x6d => instruct!("LD L L", "Load L in L",0, 4, Op::No(instruct_fn::ld_l_l)),
            0x6e => instruct!("LD L (HL)", "Load ram[HL] in L", 0, 8, Op::Ram(instruct_fn::ld_l_hlp)),
            0x6f => instruct!("LD L A", "Load A in L", 0, 4, Op::No(instruct_fn::ld_l_a)),
            //Load (HL)
            0x70 => instruct!("LD (HL) B", "Load B in ram[HL]", 0, 8, Op::Ram(instruct_fn::ld_hlp_b)),
            0x71 => instruct!("LD (HL) C", "Load C in ram[HL]", 0, 8, Op::Ram(instruct_fn::ld_hlp_c)),
            0x72 => instruct!("LD (HL) D", "Load D in ram[HL]", 0, 8, Op::Ram(instruct_fn::ld_hlp_d)),
            0x73 => instruct!("LD (HL) E", "Load E in ram[HL]", 0, 8, Op::Ram(instruct_fn::ld_hlp_e)),
            0x74 => instruct!("LD (HL) H", "Load H in ram[HL]", 0, 8, Op::Ram(instruct_fn::ld_hlp_h)),
            0x75 => instruct!("LD (HL) L", "Load L in ram[HL]", 0, 8, Op::Ram(instruct_fn::ld_hlp_l)),
            0x36 => instruct!("LD (HL) n", "Load n in ram[HL]", 1, 12, Op::RamU8(instruct_fn::ld_hlp_u8)),
            0x77 => instruct!("LD (HL) A", "Load A in ram[HL]", 0, 8, Op::Ram(instruct_fn::ld_hlp_a)),
            //Load n from A
            0x02 => instruct!("LD (BC) A", "Load A in ram[BC]", 0, 8, Op::Ram(instruct_fn::ld_bcp_a)),
            0x12 => instruct!("LD (DE) A", "Load A in ram[DE]", 0, 8, Op::Ram(instruct_fn::ld_dep_a)),
            0xEA => instruct!("LD (nn) A", "Load A in ram[nn]", 2, 16, Op::RamU16(instruct_fn::ld_u16p_a)),
            //Load A and HRam+C
            0xF2 => instruct!("LD A (C)", "Load ram[0xFF00 + C] in A", 0, 8, Op::Ram(instruct_fn::ld_a_hram_c)),
            0xE2 => instruct!("LD (C) A", "Load A in ram[0xFF00 + C]", 0, 8, Op::Ram(instruct_fn::ld_hram_c_a)),
            //Load A and decrease/increase HL
            0x3A => instruct!("LDD A (HL)", "Load ram[HL] in A, HL--", 0, 8, Op::Ram(instruct_fn::ldd_a_hlp)),
            0x32 => instruct!("LDD (HL) A", "Load A in ram[HL], HL--", 0, 8, Op::Ram(instruct_fn::ldd_hlp_a)),
            0x2A => instruct!("LDI A (HL)", "Load ram[HL] in A, HL++", 0, 8, Op::Ram(instruct_fn::ldi_a_hlp)),
            0x22 => instruct!("LDI (HL) A", "Load A in ram[HL], HL++", 0, 8, Op::Ram(instruct_fn::ldi_hlp_a)),
            //Load A and HRam + n
            0xF0 => instruct!("LDH A (n)", "Load ram[0xff00+n] in A", 1, 12, Op::RamU8(instruct_fn::ldh_a_u8)),
            0xE0 => instruct!("LDH (n) A", "Load A in ram[0xff00+n]", 1, 12, Op::RamU8(instruct_fn::ldh_u8_a)),
            //16 bits direct loads
            0x01 => instruct!("LD BC nn", "Load nn in BC", 2, 12, Op::U16(instruct_fn::ld_bc_u16)),
            0x11 => instruct!("LD DE nn", "Load nn in DE", 2, 12, Op::U16(instruct_fn::ld_de_u16)),
            0x21 => instruct!("LD HL nn", "Load nn in HL", 2, 12, Op::U16(instruct_fn::ld_hl_u16)),
            0x31 => instruct!("LD SP nn", "Load nn in SP", 2, 12, Op::U16(instruct_fn::ld_sp_u16)),
            //SP related loads
            0xF9 => instruct!("LD SP HL", "Load HL in SP", 0, 8, Op::No(instruct_fn::ld_sp_hl)),
            0xF8 => instruct!("LDHL SP n", "Load SP+n in HL", 1, 12, Op::U8(instruct_fn::ld_hl_sp_i8)),
            0x08 => instruct!("LD (nn) SP", "Load SP in ram[nn]", 2, 20, Op::RamU16(instruct_fn::ld_u16_sp)),
            //SP related PUSH
            0xF5 => instruct!("PUSH AF", "Push AF in stack, SP--*2", 0, 16, Op::Ram(instruct_fn::push_af)),
            0xC5 => instruct!("PUSH BC", "Push BC in stack, SP--*2", 0, 16, Op::Ram(instruct_fn::push_bc)),
            0xD5 => instruct!("PUSH DE", "Push DE in stack, SP--*2", 0, 16, Op::Ram(instruct_fn::push_de)),
            0xE5 => instruct!("PUSH HL", "Push HL in stack, SP--*2", 0, 16, Op::Ram(instruct_fn::push_hl)),
            //SP related POP
            0xF1 => instruct!("POP AF", "Pop from stack in AF , SP++*2", 0, 12, Op::Ram(instruct_fn::pop_af)),
            0xC1 => instruct!("POP BC", "Pop from stack in BC , SP++*2", 0, 12, Op::Ram(instruct_fn::pop_bc)),
            0xD1 => instruct!("POP DE", "Pop from stack in DE , SP++*2", 0, 12, Op::Ram(instruct_fn::pop_de)),
            0xE1 => instruct!("POP HL", "Pop from stack in HL , SP++*2", 0, 12, Op::Ram(instruct_fn::pop_hl)),
            //Add n to A
            0x87 => instruct!("ADD A A", "Add A to A", 0, 4, Op::No(instruct_fn::add_a)),
            0x80 => instruct!("ADD A B", "Add B to A", 0, 4, Op::No(instruct_fn::add_b)),
            0x81 => instruct!("ADD A C", "Add C to A", 0, 4, Op::No(instruct_fn::add_c)),
            0x82 => instruct!("ADD A D ", "Add D to A", 0, 4, Op::No(instruct_fn::add_d)),
            0x83 => instruct!("ADD A E", "Add E to A", 0, 4, Op::No(instruct_fn::add_e)),
            0x84 => instruct!("ADD A H", "Add H to A", 0, 4, Op::No(instruct_fn::add_h)),
            0x85 => instruct!("ADD A L", "Add L to A", 0, 4, Op::No(instruct_fn::add_l)),
            0x86 => instruct!("ADD A (HL)", "Add ram[HL] to A", 0, 8, Op::Ram(instruct_fn::add_hlp)),
            0xC6 => instruct!("ADD A n", "Add n to A", 1, 8, Op::U8(instruct_fn::add_u8)),
            //Add n + carry flag to A
            0x8F => instruct!("ADC A A", "Add A + Cflag to A", 0, 4, Op::No(instruct_fn::adc_a)),
            0x88 => instruct!("ADC A B", "Add B + Cflag to A", 0, 4, Op::No(instruct_fn::adc_b)),
            0x89 => instruct!("ADC A C", "Add C + Cflag to A", 0, 4, Op::No(instruct_fn::adc_c)),
            0x8A => instruct!("ADC A D", "Add D + Cflag to A", 0, 4, Op::No(instruct_fn::adc_d)),
            0x8B => instruct!("ADC A E", "Add E + Cflag to A", 0, 4, Op::No(instruct_fn::adc_e)),
            0x8C => instruct!("ADC A H", "Add H + Cflag to A", 0, 4, Op::No(instruct_fn::adc_h)),
            0x8D => instruct!("ADC A L", "Add L + Cflag to A", 0, 4, Op::No(instruct_fn::adc_l)),
            0x8E => instruct!("ADC A (HL)", "Add ram[HL] + Cflag to A", 0, 8, Op::Ram(instruct_fn::adc_hlp)),
            0xCE => instruct!("ADC A n", "Add n + Cflag to A", 1, 8, Op::U8(instruct_fn::adc_u8)),
            //Sub from A
            0x97 => instruct!("SUB A", "Sub A from A", 0, 4, Op::No(instruct_fn::sub_a)),
            0x90 => instruct!("SUB B", "Sub B from A", 0, 4, Op::No(instruct_fn::sub_b)),
            0x91 => instruct!("SUB C", "Sub C from A", 0, 4, Op::No(instruct_fn::sub_c)),
            0x92 => instruct!("SUB D", "Sub D from A", 0, 4, Op::No(instruct_fn::sub_d)),
            0x93 => instruct!("SUB E", "Sub E from A", 0, 4, Op::No(instruct_fn::sub_e)),
            0x94 => instruct!("SUB H", "Sub H from A", 0, 4, Op::No(instruct_fn::sub_h)),
            0x95 => instruct!("SUB L", "Sub L from A", 0, 4, Op::No(instruct_fn::sub_l)),
            0x96 => instruct!("SUB (HL)", "Sub ram[HL] from A", 0, 8, Op::Ram(instruct_fn::sub_hlp)),
            0xD6 => instruct!("SUB n", "Sub n from A", 1, 8, Op::U8(instruct_fn::sub_u8)),
            //Sub n + carry flag from A
            0x9F => instruct!("SBC A ", "Sub A + Cflag from A", 0, 4, Op::No(instruct_fn::sbc_a)),
            0x98 => instruct!("SBC B ", "Sub B + Cflag from A", 0, 4, Op::No(instruct_fn::sbc_b)),
            0x99 => instruct!("SBC C ", "Sub C + Cflag from A", 0, 4, Op::No(instruct_fn::sbc_c)),
            0x9A => instruct!("SBC D ", "Sub D + Cflag from A", 0, 4, Op::No(instruct_fn::sbc_d)),
            0x9B => instruct!("SBC E ", "Sub E + Cflag from A", 0, 4, Op::No(instruct_fn::sbc_e)),
            0x9C => instruct!("SBC H ", "Sub H + Cflag from A", 0, 4, Op::No(instruct_fn::sbc_h)),
            0x9D => instruct!("SBC L ", "Sub L + Cflag from A", 0, 4, Op::No(instruct_fn::sbc_l)),
            0x9E => instruct!("SBC (HL) ", "Sub ram[HL] + Cflag from A", 0, 8, Op::Ram(instruct_fn::sbc_hlp)),
            0xDE => instruct!("ADC A n", "Sub n + Cflag from A", 1, 8, Op::U8(instruct_fn::sbc_u8)),
            //and(H is SET)
            0xA7 => instruct!("AND A", "Store A & A in A", 0, 4, Op::No(instruct_fn::and_a)),
            0xA0 => instruct!("AND B", "Store B & A in A", 0, 4, Op::No(instruct_fn::and_b)),
            0xA1 => instruct!("AND C", "Store C & A in A", 0, 4, Op::No(instruct_fn::and_c)),
            0xA2 => instruct!("AND D", "Store D & A in A", 0, 4, Op::No(instruct_fn::and_d)),
            0xA3 => instruct!("AND E", "Store E & A in A", 0, 4, Op::No(instruct_fn::and_e)),
            0xA4 => instruct!("AND H", "Store H & A in A", 0, 4, Op::No(instruct_fn::and_h)),
            0xA5 => instruct!("AND L", "Store L & A in A", 0, 4, Op::No(instruct_fn::and_l)),
            0xA6 => instruct!("AND (HL)", "Store ram[HL] & A in A", 0, 8, Op::Ram(instruct_fn::and_hlp)),
            0xE6 => instruct!("AND n", "Store n & A in A", 1, 8, Op::U8(instruct_fn::and_u8)),
            //OR
            0xB7 => instruct!("OR A", "Store A | A in A", 0, 4, Op::No(instruct_fn::or_a)),
            0xB0 => instruct!("OR B", "Store B | A in A", 0, 4, Op::No(instruct_fn::or_b)),
            0xB1 => instruct!("OR C", "Store C | A in A", 0, 4, Op::No(instruct_fn::or_c)),
            0xB2 => instruct!("OR D", "Store D | A in A", 0, 4, Op::No(instruct_fn::or_d)),
            0xB3 => instruct!("OR E", "Store E | A in A", 0, 4, Op::No(instruct_fn::or_e)),
            0xB4 => instruct!("OR H", "Store H | A in A", 0, 4, Op::No(instruct_fn::or_h)),
            0xB5 => instruct!("OR L", "Store L | A in A", 0, 4, Op::No(instruct_fn::or_l)),
            0xB6 => instruct!("OR (HL)", "Store ram[HL] | A in A", 0, 8, Op::Ram(instruct_fn::or_hlp)),
            0xF6 => instruct!("OR n", "Store n | A in A", 1, 8, Op::U8(instruct_fn::or_u8)),
            //XOR(^ = XOR)
            0xAF => instruct!("XOR A", "Store A ^ A in A", 0, 4, Op::No(instruct_fn::xor_a)),
            0xA8 => instruct!("XOR B", "Store B ^ A in A", 0, 4, Op::No(instruct_fn::xor_b)),
            0xA9 => instruct!("XOR C", "Store C ^ A in A", 0, 4, Op::No(instruct_fn::xor_c)),
            0xAA => instruct!("XOR D", "Store D ^ A in A", 0, 4, Op::No(instruct_fn::xor_d)),
            0xAB => instruct!("XOR E", "Store E ^ A in A", 0, 4, Op::No(instruct_fn::xor_e)),
            0xAC => instruct!("XOR H", "Store H ^ A in A", 0, 4, Op::No(instruct_fn::xor_h)),
            0xAD => instruct!("XOR L", "Store L ^ A in A", 0, 4, Op::No(instruct_fn::xor_l)),
            0xAE => instruct!("XOR (HL)", "Store ram[HL] ^ A in A", 0, 8, Op::Ram(instruct_fn::xor_hlp)),
            0xEE => instruct!("XOR n", "Store n ^ A in A", 1, 8, Op::U8(instruct_fn::xor_u8)),
            //CMP(Z if A=n, C if A<n)
            0xBF => instruct!("CP A", "Compare A and A", 0, 4, Op::No(instruct_fn::cp_a)),
            0xB8 => instruct!("CP B", "Compare B and A", 0, 4, Op::No(instruct_fn::cp_b)),
            0xB9 => instruct!("CP C", "Compare C and A", 0, 4, Op::No(instruct_fn::cp_c)),
            0xBA => instruct!("CP D", "Compare D and A", 0, 4, Op::No(instruct_fn::cp_d)),
            0xBB => instruct!("CP E", "Compare E and A", 0, 4, Op::No(instruct_fn::cp_e)),
            0xBC => instruct!("CP H", "Compare H and A", 0, 4, Op::No(instruct_fn::cp_h)),
            0xBD => instruct!("CP L", "Compare L and A", 0, 4, Op::No(instruct_fn::cp_l)),
            0xBE => instruct!("CP (HL)", "Compare ram[HL] and A", 0, 8, Op::Ram(instruct_fn::cp_hlp)),
            0xFE => instruct!("CP n", "Compare n and A", 1, 8, Op::U8(instruct_fn::cp_u8)),
            //Inc
            0x3C => instruct!("INC A", "Increment A", 0, 4, Op::No(instruct_fn::inc_a)),
            0x04 => instruct!("INC B", "Increment B", 0, 4, Op::No(instruct_fn::inc_b)),
            0x0C => instruct!("INC C", "Increment C", 0, 4, Op::No(instruct_fn::inc_c)),
            0x14 => instruct!("INC D", "Increment D", 0, 4, Op::No(instruct_fn::inc_d)),
            0x1C => instruct!("INC E", "Increment E", 0, 4, Op::No(instruct_fn::inc_e)),
            0x24 => instruct!("INC H", "Increment H", 0, 4, Op::No(instruct_fn::inc_h)),
            0x2C => instruct!("INC L", "Increment L", 0, 4, Op::No(instruct_fn::inc_l)),
            0x34 => instruct!("INC (HL)", "Increment ram[HL]", 0, 12, Op::Ram(instruct_fn::inc_hlp)),
            //Dec
            0x3D => instruct!("DEC A", "Decrement A", 0, 4, Op::No(instruct_fn::dec_a)),
            0x05 => instruct!("DEC B", "Decrement B", 0, 4, Op::No(instruct_fn::dec_b)),
            0x0D => instruct!("DEC C", "Decrement C", 0, 4, Op::No(instruct_fn::dec_c)),
            0x15 => instruct!("DEC D", "Decrement D", 0, 4, Op::No(instruct_fn::dec_d)),
            0x1D => instruct!("DEC E", "Decrement E", 0, 4, Op::No(instruct_fn::dec_e)),
            0x25 => instruct!("DEC H", "Decrement H", 0, 4, Op::No(instruct_fn::dec_h)),
            0x2D => instruct!("DEC L", "Decrement L", 0, 4, Op::No(instruct_fn::dec_l)),
            0x35 => instruct!("DEC (HL)", "Decrement ram[HL]", 0, 12, Op::Ram(instruct_fn::dec_hlp)),
            //ADD 16 bits
            0x09 => instruct!("ADD HL BC", "Add BC to HL", 0, 8, Op::No(instruct_fn::add_hl_bc)),
            0x19 => instruct!("ADD HL DE ", "Add DE to HL", 0, 8, Op::No(instruct_fn::add_hl_de)),
            0x29 => instruct!("ADD HL HL", "Add HL to HL", 0, 8, Op::No(instruct_fn::add_hl_hl)),
            0x39 => instruct!("ADD HL SP", "Add SP to HL", 0, 8, Op::No(instruct_fn::add_hl_sp)),
            //Add Sp
            0xE8 => instruct!("ADD SP n /!\\", "Add n to SP", 1, 16, Op::No(instruct_fn::nop)), //TODO use add_16?
            //INC 16 bits
            0x03 => instruct!("INC BC", "Increment BC", 0, 8, Op::No(instruct_fn::inc_bc)),
            0x13 => instruct!("INC DE", "Increment DE", 0, 8, Op::No(instruct_fn::inc_de)),
            0x23 => instruct!("INC HL", "Increment HL", 0, 8, Op::No(instruct_fn::inc_hl)),
            0x33 => instruct!("INC SP", "Increment SP", 0, 8, Op::No(instruct_fn::inc_sp)),
            //DEC 16 bits
            0x0B => instruct!("DEC BC", "Decrement BC", 0, 8, Op::No(instruct_fn::dec_bc)),
            0x1B => instruct!("DEC DE", "Decrement DE", 0, 8, Op::No(instruct_fn::dec_de)),
            0x2B => instruct!("DEC HL", "Decrement HL", 0, 8, Op::No(instruct_fn::dec_hl)),
            0x3B => instruct!("DEC SP", "Decrement SP", 0, 8, Op::No(instruct_fn::dec_sp)),
            //SWAP
            //0x37 => instruct!("SWAP A /!\\", "Swap upper and lower nibble of A", 0, 8, Op::No(instruct_fn::nop)),
            //0x30 => instruct!("SWAP B /!\\", "Swap upper and lower nibble of B", 0, 8, Op::No(instruct_fn::nop)),
            //0x31 => instruct!("SWAP C /!\\", "Swap upper and lower nibble of C", 0, 8, Op::No(instruct_fn::nop)),
            //0x32 => instruct!("SWAP D /!\\", "Swap upper and lower nibble of D", 0, 8, Op::No(instruct_fn::nop)),
            //0x33 => instruct!("SWAP E /!\\", "Swap upper and lower nibble of E", 0, 8, Op::No(instruct_fn::nop)),
            //0x34 => instruct!("SWAP H /!\\", "Swap upper and lower nibble of H", 0, 8, Op::No(instruct_fn::nop)),
            //0x35 => instruct!("SWAP L /!\\", "Swap upper and lower nibble of L", 0, 8, Op::No(instruct_fn::nop)),
            //0x36 => instruct!("SWAP (HL) /!\\", "Swap upper and lower nibble of ram[HL]", 0, 16, Op::No(instruct_fn::nop)),
            //MISC
            0x27 => instruct!("DAA", "Adjust A to obtain a correct BCD", 0, 4, Op::No(instruct_fn::daa)),
            0x2F => instruct!("CPL", "Flip all bits of A", 0, 4, Op::No(instruct_fn::cpl)),
            0x3F => instruct!("CCF /!\\", "Flip C flag", 0, 4, Op::No(instruct_fn::nop)),
            0x37 => instruct!("SCF /!\\", "Set C flag, reset N and H", 0, 4, Op::No(instruct_fn::nop)),
            0x76 => instruct!("HALT /!\\", "Stop CPU until interrupt is received", 0, 4, Op::No(instruct_fn::nop)),
            0x10 => instruct!("STOP /!\\", "Stop CPU and LCD until button pressed", 0, 4, Op::No(instruct_fn::nop)),
            0xF3 => instruct!("DI", "Disable interrupts", 0, 4, Op::No(instruct_fn::di)),
            0xFB => instruct!("EI", "Enable interrupts", 0, 4, Op::No(instruct_fn::ei)),
            //Rotates
            0x07 => instruct!("RLCA", "Rotate A left, old bit 7 to C flag.", 0, 4, Op::No(instruct_fn::rlca)),
            0x17 => instruct!("RLA /!\\", "Rotate A left through C flag.", 0, 4, Op::No(instruct_fn::nop)),
            0x0F => instruct!("RCCA /!\\", "Rotate A right, old bit 0 to C flag.", 0, 4, Op::No(instruct_fn::nop)),
            0x1F => instruct!("RCA /!\\", "Rotate A right through C flag.", 0, 4, Op::No(instruct_fn::nop)),
            0xCB => instruct!("PREFIX 5/256/!\\", "My personal favourite <3", 1, 4, Op::RamU8(instruct_fn::prefix)),//TODO TIMING
            //(Synthé keyboard) MIGHT AS WELL JUMP (JUMP)
            0xC3 => instruct!("JP nn", "Jump to nn", 2, 16, Op::U16(instruct_fn::jp_u16)),
            0xC2 => instruct!("JP NZ nn", "Jump to nn if Z=0", 2, 12, Op::U16(instruct_fn::jp_nz_u16)),
            0xCA => instruct!("JP Z nn", "Jump to nn if Z=1", 2, 12, Op::U16(instruct_fn::jp_z_u16)),
            0xD2 => instruct!("JP NC nn", "Jump to nn if C=0", 2, 12, Op::U16(instruct_fn::jp_nc_u16)),
            0xDA => instruct!("JP C nn", "Jump to nn if C=1", 2, 12, Op::U16(instruct_fn::jp_c_u16)),
            0xE9 => instruct!("JP (HL)", "Jump to (HL)", 0, 4, Op::No(instruct_fn::jp_hl)),
            0x18 => instruct!("JR i", "Add i to PC", 1, 12, Op::U8(instruct_fn::jpr)),
            0x20 => instruct!("JR NZ i", "Add i to PC if Z=0", 1, 8, Op::U8(instruct_fn::jpr_nz)),
            0x28 => instruct!("JR Z i", "Add i to PC if Z=1", 1, 8, Op::U8(instruct_fn::jpr_z)),
            0x30 => instruct!("JR NC i", "Add i to PC if C=0", 1, 8, Op::U8(instruct_fn::jpr_nc)),
            0x38 => instruct!("JR C i", "Add i to PC if C=1", 1, 8, Op::U8(instruct_fn::jpr_c)),
            //Calls
            0xCD => instruct!("CALL nn", "Push next adress onto stack and jump to nn", 2, 24, Op::RamU16(instruct_fn::call_u16)),
            0xC4 => instruct!("CALL NZ nn", "Push next adress onto stack and jump to nn if Z=0", 2, 12, Op::RamU16(instruct_fn::call_nz_u16)),
            0xCC => instruct!("CALL Z nn", "Push next adress onto stack and jump to nn if Z=1", 2, 12, Op::RamU16(instruct_fn::call_z_u16)),
            0xD4 => instruct!("CALL NC nn", "Push next adress onto stack and jump to nn if C=0", 2, 12, Op::RamU16(instruct_fn::call_nc_u16)),
            0xDC => instruct!("CALL C nn", "Push next adress onto stack and jump to nn if C=1", 2, 12, Op::RamU16(instruct_fn::call_c_u16)),
            //Restart
            0xC7 => instruct!("RST 00", "Push present adress and jump to ram[0x0000]", 0, 16, Op::Ram(instruct_fn::rst_0)),
            0xCF => instruct!("RST 08", "Push present adress and jump to ram[0x0008]", 0, 16, Op::Ram(instruct_fn::rst_8)),
            0xD7 => instruct!("RST 10", "Push present adress and jump to ram[0x0010]", 0, 16, Op::Ram(instruct_fn::rst_10)),
            0xDF => instruct!("RST 18", "Push present adress and jump to ram[0x0018]", 0, 16, Op::Ram(instruct_fn::rst_18)),
            0xE7 => instruct!("RST 20", "Push present adress and jump to ram[0x0020]", 0, 16, Op::Ram(instruct_fn::rst_20)),
            0xEF => instruct!("RST 28", "Push present adress and jump to ram[0x0028]", 0, 16, Op::Ram(instruct_fn::rst_28)),
            0xF7 => instruct!("RST 30", "Push present adress and jump to ram[0x0030]", 0, 16, Op::Ram(instruct_fn::rst_30)),
            0xFF => instruct!("RST 38", "Push present adress and jump to ram[0x0038]", 0, 16, Op::Ram(instruct_fn::rst_38)),
            //Returns
            0xC9 => instruct!("RET", "Pop from stack and jump to adress", 0, 16, Op::Ram(instruct_fn::ret)),
            0xC0 => instruct!("RET NZ", "Pop from stack and jump to adress if Z=0", 0, 8, Op::Ram(instruct_fn::ret_nz)),
            0xC8 => instruct!("RET Z", "Pop from stack and jump to adress if Z=1", 0, 8, Op::Ram(instruct_fn::ret_z)),
            0xD0 => instruct!("RET NC", "Pop from stack and jump to adress if C=0", 0, 8, Op::Ram(instruct_fn::ret_nc)),
            0xD8 => instruct!("RET C", "Pop from stack and jump to adress if C=1", 0, 8, Op::Ram(instruct_fn::ret_c)),
            0xD9 => instruct!("RETI", "Same as RET, but enable interrupts", 0, 16, Op::Ram(instruct_fn::ret_i)),

            //Default
            _ => instruct!("NOP", "Aussi inutile que les cours de GE00", 0, 4, Op::No(instruct_fn::nop)),
        }
    }
}
